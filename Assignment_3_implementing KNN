from google.colab import drive
import io
import numpy as np
import scipy
from scipy.stats import multivariate_normal
import pandas as pd
drive.mount('/content/drive')
main_directory = '/content/drive/My Drive/PRLab/train_knn.txt'



df = pd.read_csv(main_directory, sep="," , header = None, dtype = 'float64')
print(df)



# Summarize the data
df.describe()

from google.colab import drive
import io
import numpy as np
import scipy
from scipy.stats import multivariate_normal
import pandas as pd

test_directory = '/content/drive/My Drive/PRLab/test_knn.txt'

df_test = pd.read_csv(test_directory, sep="," , header = None, dtype = 'float64')
print(df_test)

# Display the top observations present in the data
df.head()

# Check the dimensions of the data
df.shape





df_test.shape

df_train = pd.DataFrame(df)

# Rename the unnamed column to 'part'
df_result = df_train.rename(columns={df.columns[2]: 'part'})

print(df_result)




# Splitting the data into train and test based on the 'part' column
train_A = df_result[df_result['part'] == 1]
train_B = df_result[df_result['part'] == 2]



# Displaying the resulting train and test sets
print("Class BAD:")
print(train_A)

print("\nClass GOOD:")
print(train_B)


merged_data = pd.concat([train_A, train_B], ignore_index=True)

print("All data point")

print(merged_data)



def euclidean_distance(data1,data2,k):
    total_distance = 0.0
    my_array = np.array([])
    for row1 in data1.values:
        for row2 in data2.values:
            distance = 0.0
            for i in range(len(row2) - 1):
                distance += (float(row1[i]) - float(row2[i])) ** 2
            total_distance += distance ** 0.5

            my_array = np.append(my_array, total_distance)

            total_distance=0.0
        # print("value",row1[i])
        my_array= np.sort(my_array)
        print(my_array)

        for j in range(k):
          print(my_array[j])
        my_array = np.array([])






    return total_distance



k=3

distance = euclidean_distance( df_test, merged_data,k)









def euclidean_distance(data1,data2,k):

    my_array3= np.array([])
    total_distance = 0.0
    my_array = np.array([])
    list_of_array = []


    for row1 in data1.values:
        for row2 in data2.values:
            distance = 0.0
            my_array2 = np.array([])
            for i in range(len(row2) - 1):

                distance += (float(row1[i]) - float(row2[i])) ** 2
                my_array2 = np.append(my_array2, row2[i])
                #print(row2[i])

            total_distance += distance ** 0.5
            my_array2 = np.append(my_array2, total_distance)
            my_array2 = np.append(my_array2, row2[2])

            #print("corresponding dist and points")
            list_of_array.append(my_array2)

            sorted_list = sorted(list_of_array, key=lambda x: x[2])


            #print(my_array2)


            my_array = np.append(my_array, total_distance)

            total_distance=0.0
        # print("value",row1[i])
        my_array= np.sort(my_array)
        #print(my_array)
        #print(list_of_array)
        class1=0;
        class2 =0

        for j in range(k):
          #print(sorted_list[j])
          if sorted_list[j][3] == 1:
            class1+=1
          else:
            class2+=1
        if class1>class2:
          my_array3 = np.append(my_array3, "GOOD-Class(1)")
          #print("Predicted class <<GOOD>>")
        else:
          #print("Predicted class <<BAD>>")
          my_array3 = np.append(my_array3, "BAD-Class(2)")
          #print(sorted_list[j][3])

        sorted_list= ""
       # print("new")

        #for j in range(k):
         # print(sorted_list[j])
        #my_array = np.array([])




    return my_array3











k=9

my_array3 = euclidean_distance( df_test, merged_data,k)
#print(my_array3)
#print(df_test)


merged_array = np.hstack((df_test, np.expand_dims(my_array3, axis=1)))

print(merged_array)
file_path = "prediction.txt"

np.savetxt(file_path, merged_array, fmt='%s')




















